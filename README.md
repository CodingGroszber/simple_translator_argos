# Simple Translator Argos

This is a hybrid Python-Rust application for offline text translation using the [Argos Translate](https://github.com/argosopentech/argos-translate) library. The Python component handles model management, installation, and translation logic, while the Rust component spawns a PyInstaller-packaged Python executable (.exe) to perform translations via piped I/O. This setup allows for robust, cross-language interaction: Rust sends strings to the Python .exe, receives translated responses appended with "_ok", and manages process lifecycle.

The project uses [Poetry](https://python-poetry.org/) for Python dependency management and Cargo for Rust. Models are downloaded as `.argosmodel` files to `./assets/packages` and installed (unzipped) to `./assets/models` for portability.

## Features

- **Model Management**: On-demand download and installation of translation models for specific language pairs (e.g., Hungarian to English).
- **Translation Modes**:
  - **Single Mode**: Translate a single text input.
  - **Continuous Mode**: Loop for multiple translations, with support for interactive terminal input or piped I/O.
- **Pipe Mode (--pipe)**: Optimized for non-interactive use (e.g., from Rust). Skips prompts, appends "_ok" to outputs, flushes immediately, and exits cleanly on EOF.
- **Reset Functionality**: Uninstall all models and wipe data directories.
- **Logging**: Info-level by default; debug mode for detailed traces.
- **Rust Integration**: Spawns the Python .exe, handles handshake (waits for "READY" signal), sends/receives strings in a loop, captures stderr for logs/errors, and verifies successful termination.
- **Custom Asset Paths**: Overrides Argos defaults for models and packages under `./assets`.
- **Offline Support**: No internet needed after initial model downloads.
- **Error Handling**: Graceful exits on EOF/KeyboardInterrupt, with VC++ Redistributable warnings handled.

## Project Structure

```
.
├── pyproject.toml          # Poetry configuration and dependencies
├── poetry.lock             # Locked dependencies (generated by Poetry)
├── Cargo.toml              # Rust configuration and dependencies
├── Cargo.lock              # Locked Rust dependencies
├── assets/                 # Custom directory for all assets
│   ├── packages/           # Downloaded .argosmodel files
│   └── models/             # Installed (unzipped) model files
├── src/                    # Python source code
│   ├── translator.py       # Core model management and translator class
│   ├── iohandler.py        # Input/output handling for single/continuous modes
│   └── __main__.py         # Entry point with argument parsing and main logic
├── dist/                   # PyInstaller output (generated)
│   └── __main__.exe        # Packaged Python executable
├── target/                 # Rust build artifacts (generated)
├── README.md               # This file
└── main.rs                 # Rust source code (in project root or src/; adjust as needed)
```

- **assets/packages**: Stores raw downloaded model files (e.g., `hu_en.argosmodel`).
- **assets/models**: Stores unzipped/installed models used by Argos Translate.
- Paths are calculated relative to the script location using `Path(__file__).resolve().parent.parent.parent` as the base directory.

## Requirements

- **Python**: 3.13+ (tested with 3.13; compatible with 3.8+).
- **Rust**: Stable toolchain (via rustup).
- **Dependencies**:
  - Python (via Poetry): `argostranslate`, standard libraries (`pathlib`, `os`, `shutil`, `argparse`, `logging`, `traceback`, `sys`).
  - Rust: Standard library only (no external crates).
- **Build Tools**: PyInstaller for packaging Python into .exe (`pip install pyinstaller` or via Poetry).
- **Optional**: Microsoft Visual C++ Redistributable (x64) for Windows to avoid DLL warnings during runtime.

## Installation

1. **Python Setup**:
   - Install Poetry:
     ```
     pip install poetry
     ```
   - Install dependencies:
     ```
     poetry install
     ```

2. **Rust Setup**:
   - Install Rust (if not already): Download from [rust-lang.org](https://www.rust-lang.org/tools/install).
   - No additional crates needed; uses std library.

3. **Build Python .exe**:
   - Use PyInstaller to package the Python code:
     ```
     poetry run pyinstaller --onefile --console src/__main__.py --distpath dist
     ```
     - This generates `dist/__main__.exe`. Adjust paths if your entry point differs.

## Usage

### Python Standalone (Interactive or Single Translation)

Run via Poetry to activate the virtual environment:

```
poetry run python src/__main__.py [options]
```

#### Command-Line Arguments

- `--reset`: Force reset all installed models and data.
- `--from-lang <code>`: Source language code (default: `hu` for Hungarian).
- `--to-lang <code>`: Target language code (default: `en` for English).
- `--text <string>`: Text to translate in single mode (default: "Üdv világ, ez egy teszt fordítás!").
- `--single`: Enable single translation mode (default: false; uses continuous mode otherwise).
- `--debug`: Enable debug logging.
- `--pipe`: Force pipe mode (no prompts, append "_ok" to outputs; ideal for piped/Rust integration).

#### Examples

1. **Continuous Interactive Translation**:
   ```
   poetry run python src/__main__.py --from-lang hu --to-lang en
   ```
   - Prompts for input repeatedly until Ctrl+C or EOF.

2. **Single Translation**:
   ```
   poetry run python src/__main__.py --single --from-lang hu --to-lang en --text "Ezt én magam írom."
   ```
   - Outputs formatted source and target.

3. **Pipe Mode (Non-Interactive)**:
   ```
   echo "Ezt én magam írom." | poetry run python src/__main__.py --pipe --from-lang hu --to-lang en
   ```
   - Outputs: "I'll write this myself._ok"

4. **Reset**:
   ```
   poetry run python src/__main__.py --reset
   ```

### Building and Running the .exe (Standalone Python Executable)

- Build as above with PyInstaller.
- Run directly:
  ```
  dist\__main__.exe --pipe --from-lang hu --to-lang en
  ```
- For pipe mode, it signals "READY" after initialization.

### Rust Integration

The Rust component (`main.rs`) spawns the .exe, waits for "READY", sends strings, receives responses, and terminates cleanly.

- Build and Run:
  ```
  cargo run
  ```
- Hardcoded test strings (Hungarian): Can be modified in `main.rs`.
- Outputs sent/received pairs and "all translations were succesful! the end!" on success.
- Handles stderr logging in a separate thread.

## How It Works

- **Python Side**:
  - Initializes models, logs to stderr.
  - In pipe mode: Prints "READY" after setup, reads from stdin (using `input()` for EOF handling), translates, outputs "<translated>_ok" with flush, exits on EOF.
  - Interactive mode: Prompts and handles KeyboardInterrupt.
  - Environment: Sets `ARGOS_PACKAGES_DIR` before importing for custom paths.

- **Rust Side**:
  - Spawns .exe with --pipe.
  - Reads stdout until "READY" (discards warnings).
  - Sends strings via stdin, flushes.
  - Reads responses line-by-line.
  - Closes stdin to send EOF, waits for exit.
  - Verifies success and counts responses.

## Notes

- **Language Codes**: ISO 639-1 (e.g., `hu` for Hungarian, `en` for English). Check Argos docs for supported pairs.
- **VC++ Warning**: Install the redistributable from https://aka.ms/vs/16/release/vc_redist.x64.exe to resolve DLL issues.
- **Offline Use**: Requires internet for initial downloads.
- **Customization**: Adjust test strings in Rust; extend Python for more features.
- **Compatibility**: Tested on Windows (PowerShell); paths use Windows-style backslashes.

## Troubleshooting

- **Hanging Process**: Ensure Python uses `input()` for EOF detection; Rust drops stdin correctly.
- **Model Issues**: Use --debug for traces; verify paths in code.
- **PyInstaller Quirks**: Add --console for terminal support; test .exe standalone.
- **Rust Errors**: Check Cargo logs; ensure .exe path is correct ("dist\\__main__.exe").
- **Unsupported Pairs**: Script raises ValueError if unavailable.

For Argos Translate details, visit the [official repository](https://github.com/argosopentech/argos-translate).